# Chapter 7 | Malicious Windows Programs
## Lab 7-1
1. By creating a service labelled **Malservice** via `CreateServiceA` which is started during system startup. Even though the service is started with the name **MalService**, this will still run the same service due to the string comparison being case insensitive.
2. So that it ensures that only a single instance of the malware is running on the system.
3. The service name **MalService** and the mutex **HGL345** serve as host-based indicators.
4. The URL **http://www.malwareanalysisbook.com** and the user agent **Internet Explorer 8.0** are good network-based indicators.
5. Firstly, the program connects the main thread of the process to the service control manager by calling `StartServiceCtrlDispatcherA`. The service name is **MalService** and its ServiceMain function is located at `sub_401040`. Said function contains the core functionality of the service installed by the malware. Firstly, it checks if another copy its already running by making a call to `OpenMutexA` with the name **HGL345**. If it does (i.e. the return value is not NULL), then it exits via `ExitProcess`. Else, it jumps to `loc_401064`, where it creates a Mutex with the same name via `CreateMutexA`. Afterwards, `OpenSCManagerA` is called to establish a connection to the service control manager. A handle for the current process is then fetched with `GetCurrentProcess`. `GetModuleFileNameA` is then called to retrieve the path for the file that contains the running module; this is stored in the 1000-byte `Filename` buffer. After this, `CreateServiceA` installs a service started during **system startup** called **MalService** which will run as its own process under the LocalSystem account. The binary used will be the one retrieved by `GetModuleFileNameA`, which corresponds to the actual running process. ~~A timer is then set to the year 2100, so the program will run until then.~~ *A timer is set to January 1 2100 so that the actual malware only runs by then. This is ensured by creating and setting a waitable timer and then calling `WaitForSingleObject`*. At `401150`, is the function which calls `InternetOpenUrlA`. Said subroutine will be called 20 times. *This function calls itself again before finishing, hence creating an infinite loop.* At the end of the program, the service will sleep for the maximum amount of time (2^32 miliseconds). 
6. ~~The program will finish execution on January 1 2100~~ *The program will not finish execution. It will just wait until January 1 2100 and then create 20 threads of `401150`, which will eventually throw infinite requests to the hardcoded server. From this functionality we could infer that this code is designed to launch a DoS server attack against the hardcoded server's URL.*

## Lab 7-2
1. It doesn't, it simply creates and calls a **COM object**.
2. Firstly, the malware installs a **COM object** with IID = `D30C1661-CDAF-11D0-8A3E-00C04FC9E26E`, corresponding to the **IWebBrowser2 Interface**, and CLSID = `0002DF01-0000-0000-C000-000000000046`, representing Internet Explorer. It the return value of `CoCreateInstance` is null, then the program will exit after calling `OleUninitialize`. Else, it will load the string *http://www.malwareanalysisbook.com/ad.html* to memory via `SysAllocString`. The `Navigate` method (at offset `2C`) will then be called with the URL passed as a parameter. Finally, the string will be freed with `SysFreeString` and the program will end.
3. The program will finish execution after it has opened the hardcoded URL in Internet Explorer.

## Lab 7-3 | REVIEW
1. Persistence after restarting is achieved by copying the malicious DLL —containing the C2 contact functionality— to `C:\windows\system32\kerne132.dll`.
2. 2 good host-based signatures are the filename `C:\windows\system32\kerne132.dll` and the mutex *SADFHUHF*.
3. *Firstly, the .exe checks if the argument count is equal to 2, and if it's not it exits. The program then continues execution only if argv\[1\] equals WARNING_THIS_WILL_DESTROY_YOUR_MACHINE.* The executable tries to open the `C:\Windows\System32\Kernel32.dll` file via `CreateFileA`. It then copies the DLL `Lab07-03.dll` to `C:\windows\system32\kerne132.dll`. *The executable looks for all .exe files in C:\ and modifies them so that they all import the malicious DLL.* The DLL first checks if it's already running by trying to open a mutex called *SADFHUHF*. If it doesn't, it creates it. Afterwards, it creates a TCP/IP socket which will connect to the server at `127.26.152.13` on **port 80**. The code will send the string "hello" and disable send operations by calling `shutdown`. The server's response will be grabbed via `recv` and written to a 4096-byte buffer. If the C2 doesn't reply, a jump back to `100010E9` —where `send` is called with "hello"— will follow. In case the server replies with "sleep", `sleep` will be called for 393216 milliseconds followed by a jump to `100010E9`. Else if the returned string is "exec", `CreateProcessA` is called without a console window, its command line argument being the server's response after `exec` (hence the next 5 bytes after the pointer to the `recv` buffer). Lastly, the same jump back will follow. Otherwise, if the response equals the **"q" character** the **program will exit** by closing a handle and the opened socket.
4. *Since all .exe files are modified, retrieving a backup would be the best option. Another approach could be to copy the contents of the legitimate Kernel32.dll to Kernel132.dll, hence removing the malicious code although keeping the extra file.*